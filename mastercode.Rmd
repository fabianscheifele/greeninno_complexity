---
title: "master_greenpat_complexity"
author: "Fabian Scheifele"
date: "29 4 2022"
output: html_document
---


```{r}
memory.limit(size = NA)
if(!require(install.load)){
  install.packages("install.load")
  library(install.load)
}
suppressMessages(install_load("tidyverse", "dplyr", "ggplot2", "readr", "readxl","knitr","here", "tidyverse" , "anytime" , "data.table", "corrplot", "naniar", "fuzzyjoin","expss", "janitor"))
```

1. Import data 
```{r}
y2_raw<-read_csv(here("data","Y02_v07_new.csv"), locale=locale(encoding = "latin1"))
#2373038 rows compared to 1521030 in previous dataset means only 1.56 IPC codes per patent application, not a lot?

y2_raw<-y2_raw%>%rename(row_no=...1)
y2_raw<-y2_raw%>%rename(application_number=X.2)

countries<-as.data.frame(unique(y2_raw$NUTS))
#182 different countries
```

2. Clean data
```{r}
#make columns lower case
names(y2_raw) <- tolower(names(y2_raw))

# add labels to remaining variables
y2_raw<- apply_labels(y2_raw,
                      row_no = "Row number as imported",
                      application_number = "applications, numbered as imported",                       appln_id = "patstat application ID", 
                      appln_auth = "Patent Office",
                      person_id = "patstat person ID",
                      person_name = "Name of the Applicant or Inventor",
                      person_address = "All address elements of the person apart from the country",
                      nuts = "NUTS code as defined by Eurostat",
                      nuts_level = "Indicates the level of the regionalisation code in attribute NUTS, 0=state",
                      doc_std_name_id = "ID for the DOCDB standardised name",
                      doc_std_name = "Standardised name as recorded in DOCDB",
                      psn_id = "ID for the PATSTAT Standardised Name",
                      psn_level="Harmonisation level of PATSTAT standardised name",
                      psn_level=c("No harmisation"=0, "Automated harmonisation"=1, "Automated plus manual refinement"=2),
                      han_id="ID of a Harmonised Applicant Name (HAN) from OECD",
                      han_name="Harmonised Applicant Name (HAN) from OECD",
                      han_harmonized="Harmonisation indicator for OECD HAN",
                      han_harmonized=c("replinished with original name"=0, "harmonized, but not matched with orbis"=1, "harmonized and matched"=2),
                      earliest_publn_year="Year of the earliest publication date of an application", 
                      earliest_filing_year= "Year of earliest application filing",
                      docdb_family_size="family size, 1 means application is only family member", 
                      docdb_family_id ="ID of patent family"
)


#make all string variables to lower case
y2_raw <- y2_raw %>%
  mutate(across(where(is.character), tolower))


#Code factor variables
y2_raw$granted<- ifelse(y2_raw$granted=='y',1,0)

```


3. Seperate raw data into applicant and inventor file
```{r}
#Seperating applicants
applicants<-y2_raw%>%filter(applt_seq_nr==1)
applicants_nocountry<-applicants%>%filter(is.na(nuts))
  #12,58% NA's for applicant residence


#Seperating inventors
inventors<-y2_raw%>%filter(invt_seq_nr>0)%>%
  arrange(docdb_family_id, appln_id)%>%
  select(docdb_family_id,nuts,cpc_class_symbol, earliest_filing_year)
inventors_nocountry<-inventors%>%filter(is.na(nuts))
  #15% NA's for inventor residence

#Testing for number of unique CPC codes
cpc_inventor<-inventors %>%
  group_by(docdb_family_id) %>%
  mutate(unique_cpc = n_distinct(cpc_class_symbol))
summary(cpc_inventor$unique_cpc)

cpc_applicant<-applicants %>%
  group_by(docdb_family_id) %>%
  mutate(unique_cpc = n_distinct(cpc_class_symbol))
summary(cpc_applicant$unique_cpc)
  #Only one CPC code per family_id--> weird

#Testing for number of unique CPC codes
cpc<-y2_raw %>%
  group_by(docdb_family_id) %>%
  mutate(unique_cpcs_family = n_distinct(cpc_class_symbol))%>%
  ungroup()%>%
  group_by(appln_id) %>%
  mutate(unique_cpcs_appln = n_distinct(cpc_class_symbol))%>%
  select(appln_id, docdb_family_id, nuts_new, unique_cpcs_family, unique_cpcs_appln)

cpc%>%filter(unique_cpcs_appln!=unique_cpcs_family)
#there seem to be no differences between the number of unique CPC codes in invidiual applications and the overall family
```

4. Replace residence of inventor, applicant (NUTS) with Methods from de Rassenfosse (2013)
```{r}
#Check out missing data 
missing_country<-y2_raw%>%filter(is.na(nuts))
country_complete<-y2_raw%>%filter(!is.na(nuts))

#merging based on person_id (nothing found)
person_id_found<-missing_country%>%inner_join(country_complete, by=c("person_id"))

#merging based on person_id (nothing found)
han_id_found<-missing_country%>%inner_join(country_complete, by=c("han_name"))

#merging based on psn_id (too large to match)
#psn_id_found<-missing_country%>%inner_join(country_complete, by=c("psn_name"))

#Source 4: Use country of residence of the applicant, as indicated in the priority document, to proxy the country of the inventor



#Source 7: Following the method described in De Rassenfosse (2013), we replace Where available,  missing nationality with Patent Office (better would be priority patent office)
y2_raw<-y2_raw%>%mutate(nuts_new=if_else(is.na(nuts), appln_auth, nuts))
replaced<-y2_raw%>%filter(is.na(nuts))%>%select(appln_auth, nuts, nuts_new)

#Remove replaced values, where patent office is regional
`%notin%` <- Negate(`%in%`)
y2_raw<-y2_raw%>%filter(nuts_new %notin% c("ep", "wo", "ap", "em","bx", "ea", "gc", "ib", "oa", "qz", "xn", "xu", "xv"))

#Create dummy for replaced nationality values
y2_raw<-y2_raw%>%mutate(nat_replaced=if_else(nuts_new==nuts,0,1,missing = 1))
replaced<-y2_raw%>%filter(is.na(nuts))%>%select(appln_auth, nuts, nuts_new,nat_replaced)
mean(y2_raw$nat_replaced)
```

5. Creating final count datasets
```{r}
#Counting number of inventors and cpc codes per family_id
inventors<-inventors%>%group_by(docdb_family_id)%>%
  mutate(no_inventors=n())
inventors<-inventors%>%group_by(docdb_family_id)%>%
  mutate(no_cpc=n_distinct(cpc_class_symbol))

#creating fractional count variable
inventors<-inventors%>%mutate(frac_count=1/(no_cpc*no_inventors))

#Grouping the data by nationality
inventor_final<-inventors%>%group_by(nuts, cpc_class_symbol, earliest_filing_year)%>%
  summarize(frac_pat_count=sum(frac_count))
inventor_final<-inventor_final%>%arrange(nuts,earliest_filing_year, cpc_class_symbol)

#remove NA's
inventor_final<-inventor_final%>%filter(!is.na(nuts))

#Calculate RCA
inventor_final<-inventor_final%>%
  group_by(nuts, earliest_filing_year)%>%
  mutate(rta_nom=frac_pat_count/sum(frac_pat_count))%>%
  ungroup%>%
  group_by(earliest_filing_year, cpc_class_symbol)%>%
  mutate(rta_denom=frac_pat_count/sum(frac_pat_count))%>%
  ungroup%>%
  mutate(rta=rta_nom/rta_denom)

```


Archived code
```{r}
y2_subset<-y2_raw%>%select("row_no","PERSON_ID", "PERSON_NAME", "PERSON_CTRY_CODE","APPLN_ID","NUTS","DOCDB_FAMILY_ID", "DOCDB_FAMILY_SIZE", "CPC_CLASS_SYMBOL")

#perform fuzzy matching left join(https://www.statology.org/fuzzy-matching-in-r/)
#missing_country<-y2_raw%>%filter(is.na(nuts))%>%select(person_name)
#country_complete<-y2_raw%>%filter(!is.na(nuts))%>%select(person_name)

#fuzzy_name<-stringdist_join(missing_country, country_complete, 
                by='person_name', #match based on team
                mode='left', #use left join
                method = "jw", #use jw distance metric
                max_dist=0.1, 
                distance_col='dist') %>%
 # group_by(person_name.x) %>%
#  slice_min(order_by=dist, n=1)
```

